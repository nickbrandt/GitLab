# frozen_string_literal: true

class Vulnerability < ApplicationRecord
  include CacheMarkdownField
  include Redactable
  include StripAttribute
  include Noteable
  include Awardable

  TooManyDaysError = Class.new(StandardError)

  MAX_DAYS_OF_HISTORY = 10

  cache_markdown_field :title, pipeline: :single_line
  cache_markdown_field :description, issuable_state_filter_enabled: true

  strip_attributes :title

  redact_field :description

  belongs_to :project # keep this association named 'project' for correct work of markdown cache
  belongs_to :milestone
  belongs_to :epic

  belongs_to :author, class_name: 'User' # keep this association named 'author' for correct work of markdown cache
  belongs_to :updated_by, class_name: 'User'
  belongs_to :last_edited_by, class_name: 'User'
  belongs_to :resolved_by, class_name: 'User'
  belongs_to :dismissed_by, class_name: 'User'
  belongs_to :confirmed_by, class_name: 'User'

  has_one :group, through: :project

  has_many :findings, class_name: 'Vulnerabilities::Occurrence', inverse_of: :vulnerability
  has_many :issue_links, class_name: 'Vulnerabilities::IssueLink', inverse_of: :vulnerability
  has_many :related_issues, through: :issue_links, source: :issue do
    def with_vulnerability_links
      select('issues.*, vulnerability_issue_links.id AS vulnerability_link_id, '\
             'vulnerability_issue_links.link_type AS vulnerability_link_type')
    end
  end

  has_many :notes, as: :noteable, dependent: :delete_all # rubocop:disable Cop/ActiveRecordDependent
  has_many :user_mentions, class_name: 'VulnerabilityUserMention'

  enum state: { detected: 1, dismissed: 2, resolved: 3, confirmed: 4 }
  enum severity: Vulnerabilities::Occurrence::SEVERITY_LEVELS, _prefix: :severity
  enum confidence: Vulnerabilities::Occurrence::CONFIDENCE_LEVELS, _prefix: :confidence
  enum report_type: Vulnerabilities::Occurrence::REPORT_TYPES

  validates :project, :author, :title, :severity, :confidence, :report_type, presence: true

  # at this stage Vulnerability is not an Issuable, has some important attributes (and their constraints) in common
  validates :title, length: { maximum: Issuable::TITLE_LENGTH_MAX }
  validates :title_html, length: { maximum: Issuable::TITLE_HTML_LENGTH_MAX }, allow_blank: true
  validates :description, length: { maximum: Issuable::DESCRIPTION_LENGTH_MAX }, allow_blank: true
  validates :description_html, length: { maximum: Issuable::DESCRIPTION_HTML_LENGTH_MAX }, allow_blank: true

  scope :ordered, -> { order(severity: :desc) }

  scope :with_findings, -> { includes(:findings) }
  scope :with_findings_and_scanner, -> { includes(findings: :scanner) }

  scope :for_projects, -> (project_ids) { where(project_id: project_ids) }
  scope :with_report_types, -> (report_types) { where(report_type: report_types) }
  scope :with_severities, -> (severities) { where(severity: severities) }
  scope :with_states, -> (states) { where(state: states) }
  scope :counts_by_severity, -> { group(:severity).count }

  def self.counts_by_day_and_severity(start_date, end_date)
    return [] unless Feature.enabled?(:vulnerability_history, default_enabled: true)

    num_days_of_history = end_date - start_date + 1

    # this clause guards against query timeouts
    raise TooManyDaysError, "Cannot fetch counts for more than #{MAX_DAYS_OF_HISTORY} days" if num_days_of_history > MAX_DAYS_OF_HISTORY

    quoted_start_date = connection.quote(start_date)
    quoted_end_date = connection.quote(end_date)

    select(
      'DATE(calendar.entry) AS day, severity, COUNT(*)'
    ).from(
      "generate_series(DATE #{quoted_start_date}, DATE #{quoted_end_date}, INTERVAL '1 day') as calendar(entry)"
    ).joins(
      'INNER JOIN vulnerabilities ON vulnerabilities.created_at <= calendar.entry'
    ).where(
      '(vulnerabilities.dismissed_at IS NULL OR vulnerabilities.dismissed_at > calendar.entry) AND (vulnerabilities.resolved_at IS NULL OR vulnerabilities.resolved_at > calendar.entry)'
    ).group(
      :day, :severity
    )
  end

  # There will only be one finding associated with a vulnerability for the foreseeable future
  def finding
    findings.first
  end

  delegate :scanner_name, :metadata, :message, :cve,
           to: :finding, prefix: true, allow_nil: true

  delegate :default_branch, :name, to: :project, prefix: true, allow_nil: true
  delegate :name, to: :group, prefix: true, allow_nil: true

  def resource_parent
    project
  end

  def discussions_rendered_on_frontend?
    true
  end

  def resolved_on_default_branch
    return false unless findings.any?

    latest_successful_pipeline_for_default_branch = project.latest_successful_pipeline_for_default_branch
    latest_pipeline_with_vulnerability = finding.pipelines.order(created_at: :desc).first
    latest_pipeline_with_vulnerability != latest_successful_pipeline_for_default_branch
  end

  def self.parent_class
    ::Project
  end

  def self.to_ability_name
    model_name.singular
  end
end
