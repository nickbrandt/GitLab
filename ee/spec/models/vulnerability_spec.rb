# frozen_string_literal: true

require 'spec_helper'

describe Vulnerability do
  let(:state_values) { { detected: 1, dismissed: 2, resolved: 3, confirmed: 4 } }
  let(:severity_values) { { info: 1, unknown: 2, low: 4, medium: 5, high: 6, critical: 7 } }

  let(:confidence_values) do
    { undefined: 0, ignore: 1, unknown: 2, experimental: 3, low: 4, medium: 5, high: 6, confirmed: 7 }
  end
  let(:report_types) do
    { sast: 0,
      dependency_scanning: 1,
      container_scanning: 2,
      dast: 3 }
  end

  it { is_expected.to define_enum_for(:state).with_values(state_values) }
  it { is_expected.to define_enum_for(:severity).with_values(severity_values).with_prefix(:severity) }
  it { is_expected.to define_enum_for(:confidence).with_values(confidence_values).with_prefix(:confidence) }
  it { is_expected.to define_enum_for(:report_type).with_values(report_types) }

  it_behaves_like 'having unique enum values'

  describe 'associations' do
    subject { build(:vulnerability) }

    it { is_expected.to belong_to(:project) }
    it { is_expected.to belong_to(:milestone) }
    it { is_expected.to belong_to(:epic) }
    it { is_expected.to have_many(:findings).class_name('Vulnerabilities::Occurrence').inverse_of(:vulnerability) }
    it { is_expected.to have_many(:issue_links).class_name('Vulnerabilities::IssueLink').inverse_of(:vulnerability) }
    it { is_expected.to have_many(:related_issues).through(:issue_links).source(:issue) }
    it { is_expected.to belong_to(:author).class_name('User') }
    it { is_expected.to belong_to(:updated_by).class_name('User') }
    it { is_expected.to belong_to(:last_edited_by).class_name('User') }
    it { is_expected.to belong_to(:resolved_by).class_name('User') }
    it { is_expected.to belong_to(:dismissed_by).class_name('User') }
    it { is_expected.to belong_to(:confirmed_by).class_name('User') }

    it { is_expected.to have_one(:group).through(:project) }

    it { is_expected.to have_many(:findings).class_name('Vulnerabilities::Occurrence').dependent(false) }
    it { is_expected.to have_many(:notes).dependent(:delete_all) }
    it { is_expected.to have_many(:user_mentions).class_name('VulnerabilityUserMention') }
  end

  describe 'validations' do
    subject { build(:vulnerability) }

    it { is_expected.to validate_presence_of(:project) }
    it { is_expected.to validate_presence_of(:author) }
    it { is_expected.to validate_presence_of(:title) }
    it { is_expected.to validate_presence_of(:severity) }
    it { is_expected.to validate_presence_of(:confidence) }
    it { is_expected.to validate_presence_of(:report_type) }

    it { is_expected.to validate_length_of(:title).is_at_most(::Issuable::TITLE_LENGTH_MAX) }
    it { is_expected.to validate_length_of(:title_html).is_at_most(::Issuable::TITLE_HTML_LENGTH_MAX) }
    it { is_expected.to validate_length_of(:description).is_at_most(::Issuable::DESCRIPTION_LENGTH_MAX).allow_nil }
    it { is_expected.to validate_length_of(:description_html).is_at_most(::Issuable::DESCRIPTION_HTML_LENGTH_MAX).allow_nil }
  end

  describe 'text fields' do
    subject { create(:vulnerability, title: '_My title_ ', description: '**Hello `world`**') }

    it 'has proper markdown for title field' do
      expect(subject.title_html).to eq('_My title_') # no markdown rendering because it's a single line field
    end

    it 'has proper markdown for title field' do
      expect(subject.description_html).to(
        eq('<p data-sourcepos="1:1-1:17" dir="auto"><strong>Hello <code>world</code></strong></p>')
      )
    end

    context 'redactable fields' do
      before do
        stub_commonmark_sourcepos_disabled
      end

      it_behaves_like 'model with redactable field' do
        let(:model) { create(:vulnerability) }
        let(:field) { :description }
      end
    end
  end

  describe '.for_projects' do
    let(:project1) { create(:project) }
    let(:project2) { create(:project) }
    let!(:vulnerability1) { create(:vulnerability, project: project1) }
    let!(:vulnerability2) { create(:vulnerability, project: project2) }

    subject { described_class.for_projects([project1.id]) }

    it 'returns vulnerabilities related to the given project IDs' do
      is_expected.to contain_exactly(vulnerability1)
    end
  end

  describe '.with_report_types' do
    let!(:sast_vulnerability) { create(:vulnerability, :sast) }
    let!(:dast_vulnerability) { create(:vulnerability, :dast) }
    let!(:dependency_scanning_vulnerability) { create(:vulnerability, :dependency_scanning) }
    let(:report_types) { %w[sast dast] }

    subject { described_class.with_report_types(report_types) }

    it 'returns vulnerabilities matching the given report_types' do
      is_expected.to contain_exactly(sast_vulnerability, dast_vulnerability)
    end
  end

  describe '.with_severities' do
    let!(:high_vulnerability) { create(:vulnerability, :high) }
    let!(:medium_vulnerability) { create(:vulnerability, :medium) }
    let!(:low_vulnerability) { create(:vulnerability, :low) }
    let(:severities) { %w[medium low] }

    subject { described_class.with_severities(severities) }

    it 'returns vulnerabilities matching the given severities' do
      is_expected.to contain_exactly(medium_vulnerability, low_vulnerability)
    end
  end

  describe '.with_states' do
    let!(:detected_vulnerability) { create(:vulnerability, :detected) }
    let!(:dismissed_vulnerability) { create(:vulnerability, :dismissed) }
    let!(:confirmed_vulnerability) { create(:vulnerability, :confirmed) }
    let(:states) { %w[detected confirmed] }

    subject { described_class.with_states(states) }

    it 'returns vulnerabilities matching the given states' do
      is_expected.to contain_exactly(detected_vulnerability, confirmed_vulnerability)
    end
  end

  describe '.ordered' do
    subject { described_class.ordered }

    it 'returns vulnerabilities ordered by severity' do
      low_vulnerability = create(:vulnerability, :low)
      critical_vulnerability = create(:vulnerability, :critical)
      medium_vulnerability = create(:vulnerability, :medium)

      is_expected.to eq([critical_vulnerability, medium_vulnerability, low_vulnerability])
    end
  end

  describe '.counts_by_severity' do
    before do
      create_list(:vulnerability, 2, severity: :critical)
      create_list(:vulnerability, 3, severity: :high)
      create(:vulnerability, severity: :low)
    end

    subject { described_class.counts_by_severity }

    it 'returns the count for each severity' do
      is_expected.to eq({
        'critical' => 2,
        'high' => 3,
        'low' => 1
      })
    end
  end

  describe '.counts_by_day_and_severity' do
    context 'when the vulnerability_history feature flag is disabled' do
      before do
        stub_feature_flags(vulnerability_history: false)
      end

      it 'returns an empty array' do
        create(:vulnerability, created_at: 1.day.ago)

        counts_by_day_and_severity = Vulnerability.counts_by_day_and_severity(6)

        expect(counts_by_day_and_severity).to be_empty
      end
    end

    context 'when the vulnerability_history feature flag is enabled' do
      before do
        stub_feature_flags(vulnerability_history: true)
      end

      context 'when not given an end date' do
        it 'returns the count of unresolved, undismissed vulnerabilities for each severity from the current day to the given number of days in the past' do
          Timecop.freeze(Time.zone.parse('2019-10-31')) do
            create(:vulnerability, created_at: 5.days.ago, dismissed_at: Date.current, severity: :critical)
            create(:vulnerability, created_at: 5.days.ago, dismissed_at: 1.day.ago, severity: :high)
            create(:vulnerability, created_at: 4.days.ago, resolved_at: 2.days.ago, severity: :critical)

            counts_by_day_and_severity = Vulnerability.counts_by_day_and_severity(6)

            expect(counts_by_day_and_severity.order(:day, :severity).to_json).to eq([
              { 'id' => nil, 'severity' => 'high', 'day' => '2019-10-26', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-26', 'count' => 1 },
              { 'id' => nil, 'severity' => 'high', 'day' => '2019-10-27', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-27', 'count' => 2 },
              { 'id' => nil, 'severity' => 'high', 'day' => '2019-10-28', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-28', 'count' => 2 },
              { 'id' => nil, 'severity' => 'high', 'day' => '2019-10-29', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-29', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-30', 'count' => 1 }
            ].to_json)
          end
        end
      end

      context 'when given an end date' do
        it 'returns the count of unresolved, undismissed vulnerabilities for each severity for each day from the given end date to the given number of days in the past' do
          Timecop.freeze(Time.zone.parse('2019-10-31')) do
            create(:vulnerability, created_at: 5.days.ago, dismissed_at: Date.current, severity: :critical)
            create(:vulnerability, created_at: 5.days.ago, dismissed_at: 1.day.ago, severity: :high)
            create(:vulnerability, created_at: 4.days.ago, resolved_at: 2.days.ago, severity: :critical)

            counts_by_day_and_severity = Vulnerability.counts_by_day_and_severity(6, Date.parse('2019-10-28'))

            expect(counts_by_day_and_severity.order(:day, :severity).to_json).to eq([
              { 'id' => nil, 'severity' => 'high', 'day' => '2019-10-26', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-26', 'count' => 1 },
              { 'id' => nil, 'severity' => 'high', 'day' => '2019-10-27', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-27', 'count' => 2 },
              { 'id' => nil, 'severity' => 'high', 'day' => '2019-10-28', 'count' => 1 },
              { 'id' => nil, 'severity' => 'critical', 'day' => '2019-10-28', 'count' => 2 }
            ].to_json)
          end
        end
      end

      context 'when given a number of past days greater than 10' do
        it 'raises a TooManyDaysError' do
          expect { Vulnerability.counts_by_day_and_severity(11) }.to raise_error(
            Vulnerability::TooManyDaysError,
            'Cannot fetch counts for more than 10 days'
          )
        end
      end
    end
  end

  describe '#finding' do
    let_it_be(:project) { create(:project, :with_vulnerability) }
    let_it_be(:vulnerability) { project.vulnerabilities.first }
    let_it_be(:finding1) { create(:vulnerabilities_occurrence, vulnerability: vulnerability) }
    let_it_be(:finding2) { create(:vulnerabilities_occurrence, vulnerability: vulnerability) }

    subject { vulnerability.finding }

    context 'with multiple findings' do
      it { is_expected.to eq(finding1) }
    end
  end

  describe 'delegations' do
    it { is_expected.to delegate_method(:scanner_name).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:metadata).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:message).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:cve).to(:finding).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:default_branch).to(:project).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:name).to(:project).with_prefix.allow_nil }
    it { is_expected.to delegate_method(:name).to(:group).with_prefix.allow_nil }
  end

  describe '#resolved_on_default_branch' do
    let_it_be(:project) { create(:project, :repository, :with_vulnerability) }
    let_it_be(:pipeline_with_vulnerability) { create(:ci_pipeline, :success, project: project, sha: project.commit.id) }
    let_it_be(:vulnerability) { project.vulnerabilities.first }
    let_it_be(:finding1) { create(:vulnerabilities_occurrence, vulnerability: vulnerability, pipelines: [pipeline_with_vulnerability]) }
    let_it_be(:finding2) { create(:vulnerabilities_occurrence, vulnerability: vulnerability, pipelines: [pipeline_with_vulnerability]) }

    subject { vulnerability.resolved_on_default_branch }

    context 'Vulnerability::Occurrence is present on the pipeline for default branch' do
      it { is_expected.to eq(false) }
    end

    context 'Vulnerability::Occurrence is not present on the pipeline for default branch' do
      before do
        project.instance_variable_set(:@latest_successful_pipeline_for_default_branch, pipeline_without_vulnerability)
      end

      let_it_be(:pipeline_without_vulnerability) { create(:ci_pipeline, :success, project: project, sha: project.commit.id) }

      it { is_expected.to eq(true) }
    end
  end

  describe '#resource_parent' do
    let(:vulnerability) { build(:vulnerability) }

    subject(:resource_parent) { vulnerability.resource_parent }

    it { is_expected.to eq(vulnerability.project) }
  end

  describe '#discussions_rendered_on_frontend?' do
    let(:vulnerability) { build(:vulnerability) }

    subject(:discussions_rendered_on_frontend) { vulnerability.discussions_rendered_on_frontend? }

    it { is_expected.to be true }
  end

  describe '.parent_class' do
    subject(:parent_class) { Vulnerability.parent_class }

    it { is_expected.to eq(::Project) }
  end

  describe '.to_ability_name' do
    subject(:ability_name) { Vulnerability.to_ability_name }

    it { is_expected.to eq('vulnerability') }
  end

  describe '#note_etag_key' do
    let(:vulnerability) { create(:vulnerability) }

    it 'returns a correct etag key' do
      expect(vulnerability.note_etag_key).to eq(
        ::Gitlab::Routing.url_helpers.project_security_vulnerability_notes_path(vulnerability.project, vulnerability)
      )
    end
  end
end
